# Lesson 12

### Создание базы данных и её начальное заполнение при запуске приложения

Есть множество способов организовать создание базы данных и её начальное заполнение при запуске приложения.
Выбор метода зависит от используемых технологий и требований к проекту.

Вот некоторые из популярных подходов:

1. **Liquibase или Flyway**:
    - Если вы уже используете Liquibase (или альтернативный инструмент, такой как Flyway), можно создать специфический changeset или миграцию, который создает начальную структуру БД и добавляет начальные данные.
    - При запуске приложения Liquibase или Flyway автоматически применит эти миграции, если они ещё не были применены.

2. **Framework-специфичные инструменты**:
    - Многие современные фреймворки предоставляют механизмы для инициализации и миграции БД.
    - Например, в **Django** есть система миграций, а в **Ruby on Rails** — механизм миграций и seeds.

3. **ORM (Object-Relational Mapping)**:
    - Некоторые ORM позволяют автоматически создавать схему БД на основе определенных моделей. Например, в **Hibernate** есть свойство `hbm2ddl.auto`, которое может быть настроено на автоматическое создание или обновление схемы.
    - Многие ORM также предоставляют средства для заполнения БД начальными данными.

4. **SQL скрипты**:
    - Напишите SQL скрипты для создания таблиц и заполнения их данными, затем выполните их при первом запуске приложения.

5. **Контейнеризация и системы оркестрации**:
    - Если вы используете контейнеры, например Docker, можно настроить запуск определенных SQL скриптов или других инструментов при инициализации контейнера с БД.

6. **Приложение-инициализатор**:
    - Создайте отдельный компонент или модуль в вашем приложении, который будет проверять, инициализирована ли БД, и, если нет, создавать схему и заполнять начальными данными.

При выборе метода следует учитывать потребности проекта, инфраструктурные ограничения и ваш опыт работы с выбранными инструментами. В любом случае, перед автоматическим применением изменений к продакшен-БД рекомендуется тщательно тестировать процесс на тестовом окружении.


**Liquibase** — это инструмент для управления версиями баз данных, который позволяет следить за изменениями схемы базы данных и применять их последовательно. Основная идея заключается в том, чтобы сохранять историю изменений БД в виде последовательности миграций (changesets), которые можно применять и отменять.

**Принципы работы:**
1. **Файлы миграции**: Изменения БД описываются в специальных файлах (обычно XML, но могут быть и в форматах YAML, JSON и SQL).
2. **Changeset**: Основная единица изменения в Liquibase. Каждый changeset имеет уникальный идентификатор, который используется для отслеживания его применения к базе данных.
3. **DATABASECHANGELOG**: Таблица, создаваемая Liquibase в вашей БД, которая отслеживает, какие changesets были применены и когда.
4. **MD5 Checksums**: Liquibase создает контрольные суммы для каждого changeset, чтобы определить, изменился ли он после применения.
5. **Rollbacks**: Liquibase предоставляет возможность определить, как отменить примененный changeset, если это потребуется.

**Основные шаги для реализации миграции базы данных с помощью Liquibase:**
1. **Настройка Liquibase**: Установите Liquibase и настройте его для вашей базы данных.
2. **Создание файла миграции**: Создайте файл миграции (например, в формате XML) и опишите в нем желаемые изменения.
3. **Описание changesets**: В файле миграции определите один или несколько changesets, каждый из которых описывает определенное изменение в базе данных.
4. **Применение миграции**: Запустите Liquibase для применения changesets к вашей базе данных. При успешном применении changesets записываются в таблицу DATABASECHANGELOG.
5. **Откат миграции (если необходимо)**: Если вы допустили ошибку или хотите откатить изменения, вы можете использовать Liquibase для отката определенного changeset или группы changesets.
6. **Повторение**: По мере развития вашей базы данных вы будете добавлять новые changesets в файлы миграции и применять их с помощью Liquibase.


### changeSet

В контексте Liquibase термин "changeSet" используется для обозначения атомарного изменения в базе данных. Каждый changeSet описывает одно или несколько действий, которые нужно выполнить в базе данных, например, создать таблицу, добавить столбец или вставить данные. Liquibase отслеживает, какие changeSets были применены, чтобы гарантировать, что они выполнятся только один раз и в правильном порядке.

**Структура changeSet**

Основные атрибуты changeSet в Liquibase:

- `id`: Уникальный идентификатор в рамках файла миграции.
- `author`: Имя автора, обычно используется для идентификации того, кто создал changeSet.
- `changes`: Действия или изменения, которые нужно применить к базе данных.

**Пример changeSet в формате XML:**

```xml
<changeSet id="1" author="john_doe">
    <createTable tableName="new_table">
        <column name="id" type="int" autoIncrement="true" primaryKey="true"/>
        <column name="name" type="varchar(255)"/>
    </createTable>
</changeSet>
```

В этом примере создаётся новая таблица `new_table` с двумя столбцами: `id` и `name`. Идентификатор `id` служит первичным ключом и настроен на автоинкремент.

**Как это работает:**

1. **Проверка состояния**: Когда Liquibase выполняется, он сначала проверяет таблицу `DATABASECHANGELOG` в вашей базе данных, чтобы определить, какие changeSets уже были применены.

2. **Применение changeSets**: Если changeSet ещё не применён, Liquibase выполнит действия, описанные в нём. В приведённом выше примере Liquibase создаст новую таблицу.

3. **Регистрация изменений**: После успешного применения changeSet записывается в `DATABASECHANGELOG`, включая ID, имя автора и контрольную сумму. Это предотвращает повторное применение того же changeSet и позволяет отслеживать историю изменений.

**Откат изменений:**

Liquibase также поддерживает откат изменений. Вы можете определить, как отменить изменения в каждом changeSet, или позволить Liquibase сделать это автоматически для некоторых типов изменений. Однако не все типы изменений могут быть откачены автоматически, поэтому для некоторых changeSets вам может потребоваться явно указать, как выполнять откат.

**Пример отката:**

Для изменения, внесённого выше, откат может быть автоматическим, если Liquibase поддерживает откат данного типа изменения (создание таблицы). Для сложных изменений может потребоваться определить собственную логику отката.

Использование changeSets в Liquibase — это мощный способ управления миграциями базы данных, позволяющий разработчикам точно контролировать и версионировать изменения, вносимые в схему базы данных.

Liquibase контролирует и следит за изменениями, которые были применены к базе данных. Для этого он использует таблицу `DATABASECHANGELOG`. Каждый раз, когда Liquibase применяет `changeSet`, запись о нем добавляется в эту таблицу. Если `changeSet` уже был применен к базе данных, Liquibase пропустит его при следующем выполнении. Таким образом, дубликаты не будут добавлены.

Для того чтобы быть уверенным в том, что изменения будут применены только один раз, убедитесь, что каждый `changeSet` имеет уникальный идентификатор (`id`) и автора (`author`). Эти два атрибута вместе используются Liquibase для определения уникальности `changeSet`.

Если вы хотите вручную проверить, было ли применено определенное изменение, вы можете посмотреть в таблицу `DATABASECHANGELOG` и найти запись с соответствующим `id` и `author`.

Тем не менее, есть ситуации, когда вы можете захотеть проверить наличие определенных данных в таблице перед их добавлением. В этом случае вы можете использовать условную логику в вашем `changeSet`. Например, вы можете использовать предварительное условие (`preConditions`), чтобы проверить наличие данных перед их вставкой.

Пример:

```xml
<changeSet id="2" author="authorName">
    <!-- Precondition to check if Admin role already exists -->
    <preConditions onFail="MARK_RAN">
        <not>
            <sqlCheck expectedResult="0">SELECT COUNT(*) FROM roles WHERE name='Admin'</sqlCheck>
        </not>
    </preConditions>

    <!-- Insert roles -->
    <insert tableName="roles">
        <column name="id" value="1"/>
        <column name="name" value="Admin"/>
    </insert>
</changeSet>
```

В этом примере, если роль `Admin` уже существует, изменение будет помечено как выполненное (`MARK_RAN`), и действительные изменения в базу данных не будут внесены.

Таким образом, при использовании Liquibase, у вас уже есть встроенный механизм, который гарантирует, что каждый `changeSet` будет применен только один раз. Если вы хотите добавить дополнительные проверки, вы можете использовать `preConditions`.


