# Lesson 09



**Java Persistence API (JPA), Hibernate и ORM**

Java Persistence API (JPA) является частью спецификации Java EE, предоставляющей стандартизированный способ работы с реляционными базами данных в Java-приложениях. Это API облегчает разработку, позволяя инженерам манипулировать объектами Java вместо прямого взаимодействия с SQL, способствуя повышению эффективности и сокращению кода.

**Основные функции JPA:**

1. **Маппинг объектов:** JPA позволяет связывать Java-объекты с таблицами баз данных, автоматизируя процесс сохранения, извлечения, обновления и удаления данных (CRUD).
2. **Управление жизненным циклом объектов:** JPA управляет состоянием объектов от создания до удаления, обеспечивая их синхронизацию с базой данных.
3. **Кэширование:** Уменьшает количество запросов к базе данных, улучшая производительность приложений.
4. **Язык запросов JPQL:** Позволяет формировать запросы к базе данных, используя объектно-ориентированный подход.
5. **Транзакционность:** Поддерживает группировку операций в единую транзакцию для обеспечения целостности данных.


**Основные концепции ORM и JPA:**

ORM облегчает преобразование данных между несовместимыми типами систем, позволяя объектам в коде отображаться на таблицы в базе данных и наоборот. В JPA это достигается через:

- **Сущности (Entities):** Классы в Java, аннотированные как `@Entity`, соответствуют таблицам в базе данных. Атрибуты класса отображаются на столбцы таблиц.
- **EntityManager:** Основной интерфейс JPA, управляющий жизненным циклом сущностей, включая операции, такие как сохранение, удаление и запросы к данным.
- **Persistence Unit:** Определяется в `persistence.xml`, управляет конфигурацией JPA и областью видимости, в которой сущности управляются.

**Hibernate как реализация JPA:**

Hibernate расширяет функциональность JPA, предоставляя более детальное управление маппингом и конфигурацией, что улучшает взаимодействие с базой данных и производительность приложения.

**Конфигурация Hibernate:**

Hibernate, реализация JPA, может быть настроена как через XML, так и через аннотации:

- **XML-конфигурация (hibernate.cfg.xml):** Определяет параметры подключения к базе данных, выбор диалекта SQL, стратегию DDL и другие настройки. Маппинг-файлы также могут быть указаны для определения отношений между классами и таблицами.

  ```xml
  <hibernate-configuration>
    <session-factory>
      <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</property>
      <property name="hibernate.connection.url">jdbc:postgresql://localhost/mydatabase</property>
      <!-- Другие свойства -->
    </session-factory>
  </hibernate-configuration>
  ```

- **Аннотации:** Предоставляют интуитивно понятный способ маппинга классов и их атрибутов на таблицы и столбцы баз данных, делая конфигурацию более наглядной и сопровождаемой.

  ```java
  @Entity
  @Table(name = "users")
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(name = "username")
      private String username;
      // Остальные поля и методы
  }
  ```

**Применение JPA и Hibernate:**

Интеграция JPA и Hibernate в Java-приложения обеспечивает разработчикам мощный набор инструментов для работы с реляционными базами данных, позволяя сосредоточиться на объектной модели и логике приложения, а не на деталях реализации базы данных.


Spring Boot JPA (Java Persistence API) является частью большего семейства Spring Data и предоставляет удобные инструменты для работы с базами данных в Java-приложениях. Вот основные моменты, которые помогут понять, что это такое и как это работает:

1. **Что такое Spring Boot JPA?**
    - Spring Boot JPA – это модуль в Spring Boot, который упрощает интеграцию слоя доступа к данным, используя JPA (Java Persistence API). JPA – это спецификация Java, предоставляющая стандартизированный способ управления данными в базе данных в Java-приложениях.
    - Spring Boot JPA облегчает конфигурацию и управление базами данных, автоматически настраивая JPA и упрощая создание репозиториев для взаимодействия с базой данных.

2. **Как работает Spring Boot JPA?**
    - **Автоконфигурация:** В Spring Boot автоматически конфигурируются компоненты, необходимые для работы с базой данных, такие как `EntityManagerFactory`, `DataSource` и транзакционные менеджеры. Это означает, что разработчикам не нужно тратить время на ручную настройку.
    - **Репозитории:** Spring Boot JPA позволяет создавать репозитории, интерфейсы для взаимодействия с базой данных, с минимальным количеством кода. Разработчики могут определить интерфейсы, расширяющие `JpaRepository` или другие подобные интерфейсы Spring Data, и Spring автоматически создаст их реализацию во время выполнения.
    - **Объектно-реляционное отображение (ORM):** JPA использует ORM для отображения объектов Java на таблицы базы данных, позволяя разработчикам работать с базой данных с помощью объектно-ориентированных парадигм.
    - **JPQL и SQL:** JPA позволяет использовать Java Persistence Query Language (JPQL) или нативный SQL для выполнения запросов к базе данных, давая разработчикам гибкость в выборе подхода к взаимодействию с данными.

3. **Пример использования:**
    - Предположим, у вас есть класс `User`, который вы хотите отобразить на таблицу в базе данных.
    - Вы создаёте интерфейс `UserRepository`, расширяющий `JpaRepository`, и автоматически получаете множество методов для работы с пользователями, таких как сохранение, удаление, поиск и т.д., без необходимости писать дополнительный код.

Для работы с Spring Data JPA и для определения сущностей, их связей и репозиториев, используются различные аннотации из пакетов `javax.persistence` и `org.springframework`. Вот некоторые из наиболее важных аннотаций, которые часто используются в приложениях Spring Data JPA:

1. **Аннотации сущностей:**
    - `@Entity`: Определяет класс как сущность JPA, которая должна быть отображена в таблицу базы данных.
    - `@Table`: Указывает на то, с какой таблицей в базе данных ассоциирована сущность. Можно указать имя таблицы и другие детали.
    - `@Id`: Обозначает поле класса как первичный ключ сущности.
    - `@GeneratedValue`: Определяет стратегию генерации значений для первичного ключа.
    - `@Column`: Определяет отображение поля класса на столбец таблицы в базе данных. Можно указать имя столбца, его длину, уникальность и другие параметры.
    - `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`: Определяют различные типы связей между сущностями.

2. **Аннотации репозитория:**
    - `@Repository`: Помечает интерфейс как репозиторий, что также помогает в обработке исключений переводя их в исключения Spring DataAccessException.
    - `@Transactional`: Определяет область, в пределах которой должна быть гарантирована целостность выполнения операций. Может быть применена к классу или методу.

3. **Дополнительные аннотации:**
    - `@Query`: Позволяет определить пользовательский запрос на языке JPQL или нативный SQL.
    - `@Param`: Указывает параметр в пользовательском запросе, обозначенном через `@Query`.
    - `@PersistenceContext`: Используется для внедрения `EntityManager` в DAO-классы.

Эти аннотации играют ключевую роль в маппинге объектов Java на таблицы базы данных и обеспечивают удобный способ взаимодействия с данными, минимизируя необходимость написания шаблонного кода.


### `@Query` и `@Param`

Аннотация `@Query` используется для определения пользовательского запроса на языке JPQL или SQL. Аннотация `@Param` используется для указания параметров в этих запросах.

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // Пример JPQL запроса с параметром
    @Query("SELECT u FROM User u WHERE u.email = :email")
    List<User> findByEmail(@Param("email") String email);

    // Пример нативного SQL запроса с параметром
    @Query(value = "SELECT * FROM users u WHERE u.name = :name", nativeQuery = true)
    List<User> findByName(@Param("name") String name);
}
```

В этом примере, `findByEmail` использует JPQL для поиска пользователей по электронной почте, а `findByName` использует нативный SQL для поиска пользователей по имени.

### Варианты запросов:

В Spring Data JPA можно использовать несколько типов запросов:

1. **JPQL (Java Persistence Query Language):** Позволяет создавать запросы, ориентированные на сущности и их отношения, а не на таблицы и столбцы базы данных.

2. **Нативный SQL (nativeQuery):** Предоставляет возможность писать прямые SQL-запросы, что может быть полезно для использования функций, специфичных для конкретной базы данных, или когда операции не могут быть легко выражены через JPQL.

3. **Методы Spring Data JPA:** Названия методов в репозиториях могут быть автоматически трансформированы в запросы без необходимости явно их указывать, например, `findByLastName(String lastName)`.



