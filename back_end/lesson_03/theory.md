# Lesson 03

### Аннотации в Java

Аннотации в Java — это форма метаданных, которая предоставляет данные о программе, но не является частью самого исполняемого кода. Аннотации в Java имеют большое значение, так как они позволяют влиять на поведение программы без изменения её собственно кода. Они могут быть использованы для предоставления информации для компилятора, для инструментов разработки, для выполнения времени запуска (runtime) и т.д.

### Основные Концепции

1. **Определение Аннотаций**: Аннотации определяются с помощью интерфейса, перед которым ставится символ `@`. Пример: `@interface MyAnnotation {}`.
2. **Применение Аннотаций**: Для использования аннотации, её необходимо поместить перед объявлением элемента (класса, метода, поля и т.д.). Пример: `@MyAnnotation class MyClass {}`.
3. **Встроенные Аннотации**: Java предоставляет несколько встроенных аннотаций, таких как `@Override`, `@Deprecated`, `@SuppressWarnings` и др.
4. **Мета-Аннотации**: Это аннотации, применяемые к другим аннотациям. Они включают в себя `@Retention`, `@Documented`, `@Target`, `@Inherited` и `@Repeatable`.

### Мета-Аннотации

- **@Retention**: Определяет политику сохранения аннотации — как долго аннотация будет сохраняться.
    - `RetentionPolicy.SOURCE` — аннотация сохраняется только в исходном коде и отбрасывается компилятором.
    - `RetentionPolicy.CLASS` — аннотация сохраняется в файле .class, но не доступна во время выполнения.
    - `RetentionPolicy.RUNTIME` — аннотация сохраняется в файле .class и доступна во время выполнения.

- **@Target**: Определяет, к каким элементам Java может быть применена аннотация (например, классам, методам, полям).

- **@Documented**: Указывает, что аннотация должна быть документирована с использованием Javadoc.

- **@Inherited**: Указывает, что аннотация наследуется подклассами.

- **@Repeatable**: Позволяет повторное использование аннотации на одном и том же декларативном элементе.

### Примеры Использования

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyCustomAnnotation {
    String description();
}

public class MyClass {
    @MyCustomAnnotation(description = "This is a custom annotation")
    public void myMethod() {
    }
}
```

В примере выше создается кастомная аннотация `@MyCustomAnnotation`, которую затем можно использовать для методов. В данном случае аннотация содержит один элемент `description`.

Аннотации могут значительно упрощать разработку, позволяя интегрировать дополнительную информацию и обработку в код, не изменяя его логику. Они широко используются в современных Java-фреймворках и библиотеках, таких как Spring, Hibernate и JUnit.


### Пример 1: Определение и использование простой аннотации

Создадим аннотацию `@Todo`, которая может быть использована для отметки методов, требующих доработки:

```java
// Определение аннотации
@interface Todo {
    // Элемент 'description' с типом String
    String description() default "No description provided";
}

// Применение аннотации
public class MyClass {
    // Применение аннотации к методу. Указываем описание задачи.
    @Todo(description = "Need to implement this method")
    public void incompleteMethod() {
    }
}
```

В этом примере:

- `@interface Todo` определяет новую аннотацию.
- `description()` - это элемент аннотации, который может быть задан при её использовании.
- `@Todo` используется для аннотирования метода `incompleteMethod` в `MyClass`, указывая, что метод требует дальнейшей реализации.

### Пример 2: Использование мета-аннотаций

Расширим нашу аннотацию `@Todo`, используя мета-аннотации:

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// Мета-аннотации для аннотации Todo
@Retention(RetentionPolicy.RUNTIME) // Аннотация доступна во время выполнения
@Target(ElementType.METHOD) // Аннотация применима только к методам
@interface Todo {
    String description() default "No description provided";
}

public class MyClass {
    @Todo(description = "Finish this method")
    public void myMethod() {
    }
}
```

В этом примере:

- `@Retention(RetentionPolicy.RUNTIME)` говорит, что аннотация `@Todo` будет сохранена во время выполнения, что позволяет её извлекать через рефлексию.
- `@Target(ElementType.METHOD)` указывает, что аннотацию `@Todo` можно применять только к методам.

### Пример 3: Использование аннотаций во время выполнения

Рассмотрим, как можно использовать рефлексию для обработки аннотации `@Todo` во время выполнения:

```java
import java.lang.reflect.Method;

public class TodoProcessor {
    public static void process(Class<?> clazz) {
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Todo.class)) {
                Todo todo = method.getAnnotation(Todo.class);
                System.out.println("Method " + method.getName() + " needs work: " + todo.description());
            }
        }
    }

    public static void main(String[] args) {
        process(MyClass.class);
    }
}
```

В этом примере `TodoProcessor` сканирует методы класса `MyClass`, ищет аннотацию `@Todo` и выводит описание задачи. Это демонстрирует, как можно использовать аннотации для управления логикой во время выполнения, не внося изменения в основной код.

Аннотации в Java служат мощным инструментом для расширения функциональности кода, облегчения разработки и поддержки, а также для взаимодействия с различными фреймворками и библиотеками.


### Reflection API

Reflection API в Java позволяет программе анализировать саму себя или другой код во время выполнения. С его помощью можно исследовать классы, интерфейсы, поля и методы, изменять доступ к полям и вызывать методы динамически, что делает Java более гибким и мощным языком.

### Ключевые компоненты Reflection API

1. **Class Class**: Основной точкой входа в Reflection API является класс `Class`. Этот класс предоставляет методы для анализа структуры класса.

2. **Методы**: Reflection API предоставляет методы для получения информации о членах класса (поля, методы, конструкторы) и их модификаторах (public, private и т.д.).

3. **Поля**: Вы можете получить или установить значения полей объекта во время выполнения.

4. **Конструкторы**: Reflection позволяет создавать новые экземпляры классов динамически.

### Использование Reflection API

#### Получение объекта Class

Для получения объекта `Class` существует несколько способов:

```java
Class<?> c1 = String.class;
Class<?> c2 = Class.forName("java.lang.String");
Class<?> c3 = "hello".getClass();
```

#### Исследование и использование классов

После того как вы получили объект `Class`, можно исследовать структуру класса:

```java
// Получить все публичные методы класса, включая наследованные
Method[] methods = c1.getMethods();

// Получить все методы класса, независимо от модификаторов доступа
Method[] allMethods = c1.getDeclaredMethods();

// Получить конкретный метод
Method method = c1.getMethod("substring", int.class, int.class);
```

#### Создание экземпляров и вызов методов

С помощью Reflection API можно создавать экземпляры классов и вызывать методы:

```java
// Создание экземпляра класса
String s = (String) c1.newInstance();

// Вызов метода
Method concatMethod = c1.getMethod("concat", String.class);
String result = (String) concatMethod.invoke(s, "world");
```

#### Доступ к полям

Reflection API позволяет читать и изменять значения полей даже если они приватные:

```java
Field field = MyClass.class.getDeclaredField("privateField");
field.setAccessible(true); // Делаем приватное поле доступным
int fieldValue = field.getInt(myClassInstance);
field.setInt(myClassInstance, newValue);
```

### Важные замечания

- **Производительность**: Использование Reflection может быть медленнее обычных методов из-за дополнительной обработки, необходимой для анализа и взаимодействия с классами во время выполнения.

- **Безопасность**: Изменение приватных полей может нарушить инкапсуляцию и привести к нестабильности программы.

- **Обращение с Reflection**: При использовании Reflection важно обрабатывать исключения, такие как `NoSuchMethodException` или `IllegalAccessException`, поскольку они могут возникать во время выполнения, если Reflection API пытается выполнить операции, которые не разрешены текущей политикой безопасности.

Reflection API открывает множество возможностей для динамического анализа и изменения поведения программы, но его следует использовать осторожно, чтобы избежать проблем с производительностью и безопасностью.



