# Lesson 04


### Лекция: Основы Spring Core

#### Введение в Spring Framework
- **Spring Framework** — это мощный инструмент для создания приложений на Java, облегчающий управление зависимостями и конфигурацией.
- Основная цель Spring — упрощение разработки сложных приложений, предоставляя легковесный контейнер, который можно настроить через простые POJOs.

Преимущества Spring Framework

- Мультиуровневая поддержка: Spring предлагает инструменты и поддержку для каждого уровня приложения, обеспечивая полную архитектурную гибкость.
- Использование POJO: Spring работает с POJO, что упрощает программирование, уменьшает связность компонентов и повышает их тестируемость.
- Легкость интеграции и тестирования: Spring облегчает интеграцию различных модулей и их тестирование, предоставляя набор инструментов для этих целей.
- Декларативное программирование: Поддержка декларативного программирования позволяет реализовывать функциональность без необходимости писать много шаблонного кода.
- Управление ресурсами: Spring автоматизирует управление ресурсами, такими как фабричные классы и синглтоны.
- Гибкая конфигурация: Фреймворк поддерживает различные способы конфигурации, включая XML, аннотации и Java-конфигурацию.
- Поддержка middleware: Spring предоставляет обширные возможности для работы с middleware, упрощая создание сложных приложений.

#### Внедрение зависимостей и IoC (Inversion of Control)

- DI (Dependency Injection): Spring управляет зависимостями между компонентами, упрощая их связь и интеграцию.
- IoC (Inversion of Control): Spring контейнер управляет жизненным циклом объектов, что уменьшает зависимость и связность компонентов.

#### IoC (Inversion of Control)
- IoC в Spring меняет способ связывания объектов. Вместо того чтобы компоненты самостоятельно создавали или искали свои зависимости, они получают их от внешнего источника (контейнера Spring).

#### Dependency Injection (DI)
- **DI** — это реализация IoC, где объекты предоставляют друг другу необходимые зависимости через конструкторы, методы или поля.
- DI уменьшает связность компонентов и упрощает тестирование приложений.

#### Spring IoC-container
- **Spring IoC Container** управляет жизненным циклом объектов, называемых бинами, включая их создание, управление зависимостями, конфигурацию и уничтожение.

#### Beans и BeanFactory
- **Beans**: В контексте Spring бины — это объекты, которыми управляет Spring IoC контейнер. Одно из ключевых понятий в спринге — это бин. По сути, это просто объект какого-то класса.
- **BeanFactory**: Простейший контейнер, предоставляющий основные функции для управления бинами.

#### POJO
- **POJO (Plain Old Java Object)**: Простой старый Java-объект без обязательной зависимости от Spring фреймворка, что упрощает тестирование и интеграцию.

#### ApplicationContext
- **ApplicationContext** является дополнением к BeanFactory, добавляя интеграцию с более широким контекстом приложения, например, для работы с веб-приложениями.
- Вообще 'Контекст' — это набор бинов (объектов). Обращаясь к контексту — мы можем получить нужный нам бин (объект) по его имени например, или по его типу, или еще как-то.

#### Конфигурация бинов в Spring Framework
- **Bean Lifecycle**: Управляется Spring и включает этапы, такие как создание, инициализация, использование и уничтожение бина.

#### Способы конфигурации приложения
Существует три основных способа конфигурации приложения (то-есть, указания спрингу какие именно объекты нам нужны для работы):

- при помощи xml файлов/конфигов;
- при помощи java-конфигов;
- автоматическая конфигурация.

Разработчики  выстраивают их в таком порядке приоритетности:

- наиболее приоритетный способ, которому стоит отдавать предпочтение — это автоматическая конфигурация;
- если при помощи автоматической конфигурации нет возможности правильно настроить все возможные бины — использовать джава-конфигурацию (создание объектов используя джава код);
- ну и самый низкоприоритетный способ — это по-старинке, используя xml конфиги.

Кроме того, Spring позволяет комбинировать эти способы. Например, все то, что может быть настроено автоматически — пусть Spring сделает сам, там где надо указать какие-то особые параметры — сделать при помощи java-конфигов, и кроме того, можно подключить какие-то легаси конфиги в xml формате.

#### XML-конфигурации
- Бины и их зависимости традиционно конфигурировались в XML-файлах, что позволяет легко изменять конфигурацию без изменения исходного кода.

#### Java конфигурация
- В качестве альтернативы XML, Spring предлагает конфигурацию с помощью Java, используя аннотации и классы конфигурации для определения бинов.

#### Конфигурация с аннотациями
- Spring поддерживает аннотации для упрощения конфигурации бинов, такие как `@Component`, `@Service`, `@Repository` и `@Controller`.

#### Важные аннотации
- **@Required**: Указывает, что соответствующий метод сеттера в классе бина должен быть настроен для внедрения зависимости.
- **@Autowired**: Автоматически внедряет зависимость.
- **@Qualifier**: Указывает, какой именно бин должен быть внедрен, если есть несколько кандидатов.
- **@PostConstruct и @PreDestroy**: Методы, аннотированные этими аннотациями, вызываются соответственно после создания бина и перед его уничтожением.

#### Примеры кода

##### Пример Java конфигурации с аннотацией @Component
```java
@Component
public class SimpleService

 {
    public String getServiceMessage() {
        return "This is a service message";
    }
}
```

##### Конфигурационный класс с @Bean
```java
@Configuration
public class AppConfig {
    @Bean
    public SimpleService simpleService() {
        return new SimpleService();
    }
}
```

##### Использование @Autowired и @Qualifier
```java
@Component
public class Consumer {
    private final SimpleService service;

    @Autowired
    public Consumer(@Qualifier("simpleService") SimpleService service) {
        this.service = service;
    }

    public void printMessage() {
        System.out.println(service.getServiceMessage());
    }
}
```

##### Пример использования @PostConstruct и @PreDestroy
```java
@Component
public class LifecycleBean {
    @PostConstruct
    public void init() {
        System.out.println("Bean is being created");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Bean is being destroyed");
    }
}
```
    

