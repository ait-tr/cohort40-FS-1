# Lesson 04

### Лекция: Основы Spring Core

#### Введение в Spring Framework
- **Spring Framework** — это мощный инструмент для создания приложений на Java, облегчающий управление зависимостями и конфигурацией.
- Основная цель Spring — упрощение разработки сложных приложений, предоставляя легковесный контейнер, который можно настроить через простые POJOs.

Преимущества Spring Framework

- Мультиуровневая поддержка: Spring предлагает инструменты и поддержку для каждого уровня приложения, обеспечивая полную архитектурную гибкость.
- Использование POJO: Spring работает с POJO, что упрощает программирование, уменьшает связность компонентов и повышает их тестируемость.
- Легкость интеграции и тестирования: Spring облегчает интеграцию различных модулей и их тестирование, предоставляя набор инструментов для этих целей.
- Декларативное программирование: Поддержка декларативного программирования позволяет реализовывать функциональность без необходимости писать много шаблонного кода.
- Управление ресурсами: Spring автоматизирует управление ресурсами, такими как фабричные классы и синглтоны.
- Гибкая конфигурация: Фреймворк поддерживает различные способы конфигурации, включая XML, аннотации и Java-конфигурацию.
- Поддержка middleware: Spring предоставляет обширные возможности для работы с middleware, упрощая создание сложных приложений.

#### Внедрение зависимостей и IoC (Inversion of Control)

- DI (Dependency Injection): Spring управляет зависимостями между компонентами, упрощая их связь и интеграцию.
- IoC (Inversion of Control): Spring контейнер управляет жизненным циклом объектов, что уменьшает зависимость и связность компонентов.

#### IoC (Inversion of Control)
- IoC в Spring меняет способ связывания объектов. Вместо того чтобы компоненты самостоятельно создавали или искали свои зависимости, они получают их от внешнего источника (контейнера Spring).

#### Dependency Injection (DI)
- **DI** — это реализация IoC, где объекты предоставляют друг другу необходимые зависимости через конструкторы, методы или поля.
- DI уменьшает связность компонентов и упрощает тестирование приложений.

#### Spring IoC-container
- **Spring IoC Container** управляет жизненным циклом объектов, называемых бинами, включая их создание, управление зависимостями, конфигурацию и уничтожение.

#### Beans и BeanFactory
- **Beans**: В контексте Spring бины — это объекты, которыми управляет Spring IoC контейнер. Одно из ключевых понятий в спринге — это бин. По сути, это просто объект какого-то класса.
- **BeanFactory**: Простейший контейнер, предоставляющий основные функции для управления бинами.

#### POJO
- **POJO (Plain Old Java Object)**: Простой старый Java-объект без обязательной зависимости от Spring фреймворка, что упрощает тестирование и интеграцию.

#### ApplicationContext
- **ApplicationContext** является дополнением к BeanFactory, добавляя интеграцию с более широким контекстом приложения, например, для работы с веб-приложениями.
- Вообще 'Контекст' — это набор бинов (объектов). Обращаясь к контексту — мы можем получить нужный нам бин (объект) по его имени например, или по его типу, или еще как-то.

#### Конфигурация бинов в Spring Framework
- **Bean Lifecycle**: Управляется Spring и включает этапы, такие как создание, инициализация, использование и уничтожение бина.

#### Способы конфигурации приложения
Существует три основных способа конфигурации приложения (то-есть, указания спрингу какие именно объекты нам нужны для работы):

- при помощи xml файлов/конфигов;
- при помощи java-конфигов;
- автоматическая конфигурация.

Разработчики  выстраивают их в таком порядке приоритетности:

- наиболее приоритетный способ, которому стоит отдавать предпочтение — это автоматическая конфигурация;
- если при помощи автоматической конфигурации нет возможности правильно настроить все возможные бины — использовать джава-конфигурацию (создание объектов используя джава код);
- ну и самый низкоприоритетный способ — это по-старинке, используя xml конфиги.

Кроме того, Spring позволяет комбинировать эти способы. Например, все то, что может быть настроено автоматически — пусть Spring сделает сам, там где надо указать какие-то особые параметры — сделать при помощи java-конфигов, и кроме того, можно подключить какие-то легаси конфиги в xml формате.

#### XML-конфигурации
- Бины и их зависимости традиционно конфигурировались в XML-файлах, что позволяет легко изменять конфигурацию без изменения исходного кода.

#### Java конфигурация
- В качестве альтернативы XML, Spring предлагает конфигурацию с помощью Java, используя аннотации и классы конфигурации для определения бинов.

#### Конфигурация с аннотациями
- Spring поддерживает аннотации для упрощения конфигурации бинов, такие как `@Component`, `@Service`, `@Repository` и `@Controller`.

#### Важные аннотации
- **@Required**: Указывает, что соответствующий метод сеттера в классе бина должен быть настроен для внедрения зависимости.
- **@Autowired**: Автоматически внедряет зависимость.
- **@Qualifier**: Указывает, какой именно бин должен быть внедрен, если есть несколько кандидатов.
- **@PostConstruct и @PreDestroy**: Методы, аннотированные этими аннотациями, вызываются соответственно после создания бина и перед его уничтожением.

#### Примеры кода

##### Пример Java конфигурации с аннотацией @Component
```java
@Component
public class SimpleService

 {
    public String getServiceMessage() {
        return "This is a service message";
    }
}
```

##### Конфигурационный класс с @Bean
```java
@Configuration
public class AppConfig {
    @Bean
    public SimpleService simpleService() {
        return new SimpleService();
    }
}
```

##### Использование @Autowired и @Qualifier
```java
@Component
public class Consumer {
    private final SimpleService service;

    @Autowired
    public Consumer(@Qualifier("simpleService") SimpleService service) {
        this.service = service;
    }

    public void printMessage() {
        System.out.println(service.getServiceMessage());
    }
}
```

##### Пример использования @PostConstruct и @PreDestroy
```java
@Component
public class LifecycleBean {
    @PostConstruct
    public void init() {
        System.out.println("Bean is being created");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Bean is being destroyed");
    }
}
```


### @Component

Аннотация `@Component` используется для указания того, что класс является компонентом Spring. Компоненты автоматически обнаруживаются благодаря сканированию путей классов. Эта аннотация говорит Spring создать бин (bean) для такого класса и управлять им как синглтоном (по умолчанию).

Пример:
```java
@Component
public class MyComponent {
    // ...
}
```

### @Autowired

`@Autowired` обозначает, что автоматическое внедрение зависимостей должно произойти через указанный конструктор, поле, сеттер или метод. Spring решает, какой экземпляр внедрить, основываясь на доступных бинах в контексте.

Пример:
```java
@Component
public class MyService {
    private MyRepository repository;

    @Autowired
    public MyService(MyRepository repository) {
        this.repository = repository;
    }
}
```

### @Qualifier

`@Qualifier` уточняет, какой именно бин должен быть внедрен, когда имеется несколько кандидатов. Она помогает избежать путаницы, указывая конкретное имя бина для внедрения.

Пример:
```java
@Autowired
@Qualifier("specificRepository")
private MyRepository repository;
```

### @Value

Аннотация `@Value` используется для внедрения значений из property-файлов в поля класса. Это может быть полезно для внедрения настроек конфигурации, которые могут меняться вне кода.

Пример:
```java
@Component
public class MyComponent {
    @Value("${my.value}")
    private String value;
}
```

Аннотация `@Autowired` может использоваться для конструктора, что является одним из способов внедрения зависимостей в Spring.
Когда вы используете `@Autowired` на конструкторе, Spring автоматически внедряет зависимости, которые этот конструктор требует.
В нашем примере, `MyRepository` внедряется через конструктор `MyService`.

Когда `@Autowired` применяется к конструктору, нет необходимости ставить `@Autowired` на отдельные поля (например, `private MyRepository repository;`), так как зависимость уже внедряется через конструктор.
Это один из предпочтительных методов внедрения зависимостей в Spring, поскольку он поддерживает иммутабельность компонентов и облегчает тестирование.

По поводу удаления конструктора: если ваш класс имеет только один конструктор, Spring с версии 4.3 поддерживает автоматическое внедрение зависимостей без необходимости явно указывать `@Autowired` на конструкторе.
Это означает, что если у вас только один конструктор, Spring автоматически использует его для внедрения зависимостей, и вы можете опустить `@Autowired`.

Пример без `@Autowired` на конструкторе и без явного конструктора (используется конструктор по умолчанию и внедрение в поле):

```java
@Component
public class MyService {
    @Autowired
    private MyRepository repository;
}
```

Однако, использование конструктора для внедрения зависимостей (конструкторное внедрение) является предпочтительным подходом, так как это обеспечивает неизменность зависимостей и упрощает тестирование компонента,
позволяя передавать все зависимости через конструктор, что делает очевидными все требуемые зависимости для создания экземпляра класса.


