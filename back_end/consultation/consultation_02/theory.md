

###  Многопоточность. 

1. **Введение**
    - История вычислительной техники начинается с механических вычислительных машин XIX века.
    - XX век принес компьютеры в современном понимании.
    - Развитие технологий привело к сокращению размеров ЭВМ и увеличению их производительности и энергоэффективности.
    - Возникновение микросборок и микросхем.
    - Формулировка «закона» Мура о росте количества транзисторов на кристалле.

2. **Основные элементы в компьютере**
    - Процессор как центральный элемент, выполняющий инструкции программ.
    - Эволюция процессоров от одноядерных к многоядерным для повышения производительности.

3. **Краткое описание работы процессора**
    - АЛУ (арифметико-логическое устройство) как главный элемент процессора.
    - Регистры, шины данных и адреса, дешифратор команд.
    - Основные операции АЛУ и принципы их выполнения.

4. **Поддержка на уровне операционной системы**
    - ОС распределяет процессорное время между процессами разными способами: простое переключение задач, кооперативная и вытесняющая многозадачность.
    - Различие между кооперативной и вытесняющей многозадачностью по способу распределения процессорного времени.

5. **Концепции вычислений**
    - Последовательные вычисления, где задачи выполняются одна за другой.
    - Параллельные вычисления, позволяющие выполнять множество задач одновременно на многоядерных процессорах.

6. **Процессы и потоки**
    - Определение процесса и потока, их особенности и различия.
    - Процессы как независимые единицы с собственными ресурсами.
    - Потоки как единицы выполнения внутри процесса, делящие его ресурсы.
    - Отличия потоков от процессов по набору информации, использованию памяти и скорости переключения.

7. **Многопоточность и алгоритм разделения времени**
    - Алгоритм time-slicing для распределения процессорного времени между потоками.
    - Различие между имитацией параллельности в одноядерных системах и реальной параллельностью в многоядерных системах.
    - Влияние многопоточности на производительность и ресурсы системы.

8. **Преимущества и недостатки многопоточности**
    - Улучшение адаптивности и производительности приложений благодаря многопоточности.
    - Сложности проектирования и отладки многопоточных приложений.
    - Проблемы с синхронизацией данных и переключением контекста между потоками.


#### 2.1 Средства для работы с многопоточностью в Java
- **Java 1.0**: `Thread`, `Runnable`, `synchronized`, `wait()`, `notify()`, `notifyAll()`.
- **Java 1.5**: Пакет `java.util.concurrent` с расширенными возможностями.
- **Java 1.8**: `CompletableFuture` для асинхронных задач и их комбинирования.

#### Модели многопоточных программ
- Синхронизация, блокировки, `volatile`.
- Транзакционная память, рекурсивный параллелизм.
- Модель акторов: объекты как потоки обмениваются сообщениями.

#### Проблемы, решаемые многопоточностью (продолжение)
1. **Одновременное выполнение нескольких действий**: Многопоточность позволяет программе выполнять несколько задач одновременно, улучшая интерактивность и отзывчивость.
2. **Ускорение вычислений**: Использование многопоточности позволяет эффективно распределить задачи между ядрами процессора, сокращая общее время выполнения программы.

#### Проблемы, создаваемые многопоточностью

1. **Взаимная блокировка (Deadlock)**: Состояние, при котором два или более потоков ждут ресурсы, захваченные друг другом, и не могут продолжить выполнение.
2. **Состояние гонки (Race Condition)**: Ошибка проектирования, когда работа системы становится зависимой от последовательности выполнения потоков. Это может привести к непредсказуемому поведению программы.

#### Что должен знать Java-разработчик о многопоточности

**Уровень Junior**:
- Основы реализации многопоточности в Java.
- Синтаксические конструкции, связанные с потоками.
- Основы пакета `java.util.concurrent`.

**Уровень Middle**:
- Глубокое понимание стандартных библиотек и инструментов Java для многопоточности.
- Понимание многопоточности в контексте Spring.
- Способность самостоятельно разрабатывать многопоточный функционал.

**Уровень Senior**:
- Продвинутое знание инструментов и библиотек для многопоточности.
- Понимание применения инструментов многопоточности в различных сценариях.
- Умение архитектурно интегрировать многопоточность в приложения.



1. **Создание и запуск потоков в Java**
   В Java потоки можно создавать двумя способами: наследуясь от класса `Thread` или реализуя интерфейс `Runnable`.

    - **Пример с наследованием от класса Thread:**

      ```java
      class MyThread extends Thread {
          public void run() {
              System.out.println("Поток запущен: " + Thread.currentThread().getName());
          }
      }
 
      public class Main {
          public static void main(String[] args) {
              MyThread thread = new MyThread();
              thread.start();
          }
      }
      ```

    - **Пример с реализацией интерфейса Runnable:**

      ```java
      class MyRunnable implements Runnable {
          public void run() {
              System.out.println("Поток запущен: " + Thread.currentThread().getName());
          }
      }
 
      public class Main {
          public static void main(String[] args) {
              Thread thread = new Thread(new MyRunnable());
              thread.start();
          }
      }
      ```

2.  **Средства для работы с многопоточностью в Java и модели многопоточных программ**

1. **Инструменты многопоточности в Java:**
    - В первых версиях Java средства многопоточности ограничивались классом `Thread`, интерфейсом `Runnable`, ключевым словом `synchronized`, и методами `wait()`, `notify()`, `notifyAll()` в классе `Object`.
    - С Java 1.5 появился пакет `java.util.concurrent`, вносящий значительные улучшения и расширения в инструментарий для работы с многопоточностью.
    - В Java 1.8 был добавлен класс `CompletableFuture` для создания асинхронных задач и их комбинирования.

2. **Модели многопоточного программирования:**
    - **Синхронизация и блокировки:** использование `synchronized` и `volatile` для управления доступом к общим ресурсам и обеспечения видимости изменений переменных между потоками.
    - **Транзакционная память:** обеспечивает абстракцию, позволяющую управлять доступом к памяти в многопоточных приложениях, упрощая разработку за счет автоматического контроля за блокировками и изменениями.
    - **Модель акторов:** в этой модели каждый объект (актор) является отдельным потоком и взаимодействует с другими акторами исключительно посредством обмена сообщениями, что уменьшает риск гонок данных и упрощает разработку.

3. **Способы организации многопоточности в программах:**
    - Потоки могут работать независимо друг от друга, не взаимодействуя напрямую.
    - Потоки могут активно взаимодействовать друг с другом, координируя выполнение задач.
    - Потоки могут работать независимо, а затем собирать свои результаты в единый выходной результат.

4. **Потоки в Java:**
    - `Thread` — базовый класс для создания потоков.
    - Создание потоков может происходить через наследование от `Thread` и переопределение метода `run()` или через реализацию интерфейса `Runnable` с последующей передачей его экземпляра в конструктор `Thread`.
    - Предпочтительнее использовать `Runnable` для создания потоков, так как это обеспечивает большую гибкость и позволяет избежать ограничений, связанных с наследованием.

5. **Управление потоками:**
    - Метод `start()` запускает поток, в то время как вызов `run()` просто выполняет код в текущем потоке.
    - Можно устанавливать приоритеты потоков, используя метод `setPriority()`, что влияет на распределение времени процессора между потоками.
    - Потоки-демоны (`daemon threads`) — это служебные потоки, которые не препятствуют завершению работы JVM.
    - Группировка потоков через `ThreadGroup` позволяет управлять группами потоков как единым целым.
    - Метод `join()` позволяет одному потоку ожидать завершения работы другого потока.
    - Приостановка выполнения потока может быть реализована с помощью `Thread.sleep()`

