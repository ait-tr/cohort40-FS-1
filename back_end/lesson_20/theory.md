# Lesson 20

## 01. Загрузка файлов

*
* Если загружать все файлы пользователей, то сильно возрастает нагрузка на сервер
    * Потому что все запросы на получение файлов будут проходить через нас
    * Также, файлы будут занимать очень много места и вам скоро его не хватит

* Целесообразно это переложить на сторонние решения, по типу - `Dropbox`, `AWS S3`, `Digital Ocean Spaces`

* Это облачные хранилища с возможностями быстрой доставки контента (безграничная память и высокая скорость)
* Преимущество стороннего решения в очень высокой скорости доставки контента без нагрузки вашего сервера

## 02. Типовая загрузка файлов в локальное хранилище

```
    @PostMapping("/api/files")
    public StandardResponseDto upload(@RequestParam("file") MultipartFile file) {
        String originalFileName = file.getOriginalFilename(); // получаем имя файла оригинальное

        String extension;

        if (originalFileName != null) {
            extension = originalFileName.substring(originalFileName.lastIndexOf(".") + 1); // забираем расширение файла
        } else {
            throw new IllegalArgumentException("null original file name");
        }

        String uuid = UUID.randomUUID().toString(); // генерируем случайную строку в формате UUID
        String newFileName = uuid + "." + extension; // создаем новое имя файла, которое состоит из случайной строки и расширения

        try (InputStream inputStream = file.getInputStream()) { // открываем у загружаемого файла поток для чтения
            Files.copy(inputStream, Path.of("C:\\Users\\marse\\Desktop\\OnlineShop\\static\\" + newFileName)); // перекидываем данные из потока для чтения
            // к нам на диск
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }

        return StandardResponseDto.builder()
                .message(newFileName)
                .build();
    }
```
## 03. Подключение S3/DigitalOcean

```xml
<dependency>
  <groupId>com.amazonaws</groupId>
  <artifactId>aws-java-sdk-s3</artifactId>
  <version>1.12.572</version>
</dependency>
```

* `sdk3-s3` - значительно упрощает работу с сервисом


Перенос хранения файлов из локальной среды на внешнее облачное хранилище, такое как Digital Ocean Spaces, предоставляет ряд преимуществ, даже если файлы изначально загружаются через ваш сервер. Вот некоторые из ключевых преимуществ:

1. **Масштабируемость**: Облачные хранилища легко масштабируются. Вам не придется беспокоиться о достаточности дискового пространства на вашем сервере, так как можно легко увеличить объем хранения в облаке в зависимости от нужд.

2. **Надежность и доступность**: Облачные хранилища обеспечивают высокую степень доступности и надежности данных. Ваши файлы будут размещены в дата-центрах, которые гарантируют их сохранность даже в случае сбоя вашего физического сервера.

3. **Безопасность**: Провайдеры облачных услуг обычно предлагают расширенные возможности безопасности, такие как шифрование данных во время передачи и хранения, а также различные опции для управления доступом и аудита.

4. **Снижение затрат**: Хранение данных в облаке может быть более экономичным по сравнению с управлением собственной инфраструктурой хранения. Вы платите только за то, что используете, и избавляетесь от затрат на обслуживание и амортизацию физических серверов.

5. **Управление и обслуживание**: Облачные провайдеры берут на себя всю тяжесть управления и поддержки хранилища, что позволяет вам сконцентрироваться на развитии вашего приложения.

6. **Глобальный доступ**: Файлы, размещенные в облаке, могут быть легко доступны из любой точки мира, что улучшает производительность для пользователей, расположенных далеко от вашего основного сервера.

7. **Бэкап и восстановление**: Многие облачные сервисы предлагают встроенные решения для резервного копирования и восстановления, что повышает устойчивость вашего приложения к потере данных.

Чтобы интегрировать хранение в облаке Digital Ocean с вашим Spring Boot приложением, вы можете использовать библиотеки и SDK, предоставляемые Digital Ocean, или сторонние библиотеки, поддерживающие S3-совместимые API (поскольку Digital Ocean Spaces совместим с API S3).
Это позволит вашему приложению работать с облачным хранилищем так же, как с любым другим S3-совместимым хранилищем.


## Переменные окружения в Spring Boot

Это параметры конфигурации, которые управляют поведением приложения в различных средах (разработка, тестирование, продакшн).
Они представляют собой внешний способ передачи конфигурационных данных в приложение, что позволяет избежать хардкода значений непосредственно в коде.

### Как использовать переменные окружения в Spring Boot

1. **Определение переменных окружения:**
   Переменные окружения могут быть определены в операционной системе или в конфигурационных файлах CI/CD. Например, в Unix-подобных системах вы можете задать переменную окружения в терминале:
   ```bash
   export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
   ```

2. **Доступ к переменным окружения в приложении:**
   В Spring Boot для доступа к переменным окружения можно использовать аннотацию `@Value`. Например:
   ```java
   @Component
   public class MyComponent {
       @Value("${DATABASE_URL}")
       private String databaseUrl;

       // использование databaseUrl в коде
   }
   ```

3. **Использование `application.properties` или `application.yml`:**
   Вы можете задать значения по умолчанию в этих файлах, которые будут перезаписаны значениями из переменных окружения при необходимости:
   ```properties
   # application.properties
   DATABASE_URL=jdbc:h2:mem:testdb
   ```

   ```yaml
   # application.yml
   DATABASE_URL: jdbc:h2:mem:testdb
   ```

### Нюансы использования переменных окружения в Spring Boot

1. **Приоритеты конфигурации:**
   Spring Boot использует строгую иерархию для определения приоритета конфигурационных данных. Переменные окружения имеют один из самых высоких приоритетов, что позволяет им перезаписывать значения, заданные в `application.properties` или `application.yml`.

2. **Безопасность:**
   Старайтесь не хранить чувствительные данные, такие как пароли или секреты API, прямо в переменных окружения. Используйте для этого защищенные хранилища, например, Spring Cloud Config или HashiCorp Vault.

3. **Профили Spring:**
   Вы можете определить различные профили для разных сред, используя `spring.profiles.active` и определяя переменные окружения для каждой среды соответственно. Это позволяет гибко управлять конфигурацией для различных условий развертывания.

4. **Передача сложных структур данных:**
   Если вам нужно передать сложные структуры данных через переменные окружения, подумайте о форматировании их как строк, возможно, в JSON-формате, который затем можно разобрать в приложении.

Использование переменных окружения улучшает безопасность и упрощает управление конфигурациями приложения, делая его более гибким и адаптируемым к изменениям среды.

При запуске приложения на Spring Boot переменные окружения можно задать несколькими способами в зависимости от среды и способа запуска. Вот несколько основных методов:

### 1. В командной строке
Вы можете установить переменные окружения прямо перед запуском приложения в командной строке. Это работает на любой операционной системе.

**На UNIX-подобных системах (Linux, macOS):**
```bash
export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
java -jar myapp.jar
```

**На Windows:**
```cmd
set DATABASE_URL=jdbc:mysql://localhost:3306/mydb
java -jar myapp.jar
```

### 2. При запуске через Maven или Gradle
Если вы используете Maven или Gradle для запуска вашего приложения во время разработки, вы можете указать переменные окружения в конфигурации плагина.

**Для Maven:**
```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <environmentVariables>
            <DATABASE_URL>jdbc:mysql://localhost:3306/mydb</DATABASE_URL>
        </environmentVariables>
    </configuration>
</plugin>
```
Затем запускаете:
```bash
mvn spring-boot:run
```

**Для Gradle:**
```groovy
bootRun {
    environment "DATABASE_URL", "jdbc:mysql://localhost:3306/mydb"
}
```
Затем запускаете:
```bash
./gradlew bootRun
```

### 3. В файле конфигурации IDE
Если вы используете IDE, такие как IntelliJ IDEA или Eclipse, вы можете установить переменные окружения в настройках конфигурации запуска вашего приложения.

**В IntelliJ IDEA:**
- Откройте конфигурацию запуска (Run/Debug Configurations).
- Найдите раздел "Environment variables" и установите нужные переменные.

**В Eclipse:**
- Откройте конфигурацию запуска (Run Configurations).
- Во вкладке "Environment" добавьте необходимые переменные окружения.

### 4. В Docker или Kubernetes
При запуске приложений в контейнерах (например, с использованием Docker или Kubernetes) вы также можете задать переменные окружения через конфигурацию контейнера.

**Docker:**
```dockerfile
FROM openjdk:11
COPY target/myapp.jar myapp.jar
ENV DATABASE_URL jdbc:mysql://localhost:3306/mydb
ENTRYPOINT ["java", "-jar", "myapp.jar"]
```

**Kubernetes:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: myapp
    image: myapp:latest
    env:
    - name: DATABASE_URL
      value: "jdbc:mysql://localhost:3306/mydb"
```

Эти методы позволяют гибко управлять конфигурацией приложения, адаптируя её под разные среды и условия запуска.

## Тестирование контроллеров в Spring Boot

Тестирование контроллеров в Spring Boot обычно включает использование фреймворка `MockMvc`, который позволяет отправлять HTTP-запросы на контроллеры и проверять ответы без запуска полноценного сервера. Вот подробное объяснение основных методов и подходов:

### 1. Инициализация `MockMvc`

- **`MockMvcBuilders.standaloneSetup`**: Этот метод используется для создания конфигурации `MockMvc` для тестирования одного или нескольких контроллеров в изоляции от остальной части приложения. Это идеально подходит для модульного тестирования, так как не требуется загружать полный контекст Spring.
- **`MockMvcBuilders.webAppContextSetup`**: Этот метод требует загрузки полного веб-контекста приложения, что делает его подходящим для интеграционных тестов.

### 2. Конфигурация тестов

- **`@SpringBootTest`**: Эта аннотация используется для загрузки полноценного контекста приложения и применяется в интеграционных тестах, подходит для проверки реального поведения приложения в среде, максимально приближенной к продуктивной.
- **`@WebMvcTest`**: Специализированная аннотация для тестирования MVC контроллеров, которая загружает только необходимые для контроллера компоненты, такие как конвертеры и валидаторы, без запуска полного контекста Spring.

### 3. Настройка и использование `MockMvc`

- **`.perform(RequestBuilder requestBuilder)`**: Основной метод для отправки HTTP-запросов. `RequestBuilder` создается для имитации различных HTTP-запросов, как `get()`, `post()` и др.
- **`.andExpect(ResultMatcher matcher)`**: Метод для проверки ответов контроллера. Позволяет проверить статус ответа, содержимое ответа, заголовки и другие аспекты.

### 4. Проверка результатов

- **`status()`**: Проверка статуса HTTP-ответа, например, успешен ли он (`isOK()`) или привел ли к ошибке (`isBadRequest()`).
- **`jsonPath(String expression, Matcher<?> matcher)`**: Используется для проверки конкретных данных в JSON-ответе, например, содержит ли поле `name` в ответе ошибку валидации.

### 5. Обработка исключений и мокирование

- **`@MockBean`**: Аннотация для добавления моков в контекст Spring теста. Позволяет заменить реальные бины на подделки для контроля поведения зависимостей.
- **`when()` и `thenReturn()`**: Методы из библиотеки Mockito для настройки поведения моков. Например, можно настроить мок сервиса так, чтобы при вызове метода возвращалось исключение или специфический результат.

Эти методы и подходы позволяют гибко настраивать тестирование контроллеров в Spring Boot, обеспечивая как широкое покрытие функциональности, так и детализированную проверку каждого аспекта взаимодействия клиента с сервером.





